
# Базовая задача

Разработать приложение, повторяющее состояние входного сигнала GPIO
на выходном сигнале GPIO. Номера сигналов GPIO выбираются аргументами
командной строки. Управление сигналами GPIO осуществляется через
виртуальную файловую систему sysfs.

## Описание базовой задачи

На устройстве Корунд-2О-8Е располагаются 10 Ethernet портов, две пары сухих
контактов (ВХОДЫ 1 и 2), два индикатора (ВКЛ и АВАРИЯ), слот для SD-карты,
последовательный порт (RS-232) и порт питания. На каждом из портов 3-10
располагаются два индикатора (зеленый и желтый). Соответствие желтых
индикаторов портов 3-10 номерам сигналов GPIO указано в следующей таблице:

| Номер порта | Номер сигнала GPIO |
|:-----------:|:------------------:|
|      3      |         478        |
|      4      |         479        |
|      5      |         476        |
|      6      |         477        |
|      7      |         474        |
|      8      |         475        |
|      9      |         472        |
|      10     |         473        |

## Предварительная подготовка

Для того, чтобы пользователь мог работать с сигналами GPIO необходимо
экспортировать эти сигналы в пользовательское пространство управления.
Экспортировать сигнал GPIO можно записав номер сигнала GPIO в файл
*/sys/class/gpio/export*. Запись в файл осуществляется с помощью shell-команды:
*echo **N** > /sys/class/gpio/export*, где **N** это номер сигнала GPIO.
Для отмены экспорта необходимо записать номер сигнала GPIO в файл
*/sys/class/gpio/unexport*. Примеры:

```console
$ echo 472 > /sys/class/gpio/export
$ echo 472 > /sys/class/gpio/unexport
```

Перед выполнением работы необходимо экспортировать все сигналы GPIO:

```console
$ for i in $(seq 472 479); do echo $i > /sys/class/gpio/export; done
```

После экспортирования доступ к сигналу GPIO можно получить используя путь
*/sys/class/gpio/gpio**N***, где **N** это номер сигнала GPIO. Пример:
*/sys/class/gpio/gpio472*.

## Алгоритм решения базовой задачи

1. Осуществить анализ аргументов командной строки с помощью **argv**
   и **argc**. В качестве аргументов командной строки использовать следующие:

   - **IN_GPIO** для аргумента, соответствующего входному сигналу GPIO;
   - **OUT_GPIO** для аргумента, соответствующего выходному сигналу GPIO.

   Все аргументы являются позиционными и обязательными. В случае отсутствия
   аргумента **IN_GPIO** и/или **OUT_GPIO** необходимо записать соответствующее
   сообщение об ошибке в стандартный поток ошибки (stderr) и завершить
   программу с кодом возврата **EXIT_FAILURE**.

2. Реализовать копирование значений сигналов GPIO с помощью цикла. На каждой
   итерации цикла выполнить следующие действия:

   - Прочитать значение входного сигнала GPIO из файла
     */sys/class/gpio/gpio**IN_GPIO**/value*.
   - Записать прочитанное значение в файл
     */sys/class/gpio/gpio**OUT_GPIO**/value*.
   - Задержать выполнение цикла на 100 мс.

   Для открытия файла используется функция [open(2)][1]. Для чтения и записи
   функции [read(2)][2] и [write(2)][3], соответственно. Необходимо отметить,
   что если для чтения и записи используется одно и то же файловое открытие, то
   после каждой операции чтения/записи необходимо устанавливать файловое
   смещение в **0**. Для изменения текущего файлового смещения необходимо
   использовать функцию [lseek(2)][4]. Чтобы задержать выполнение цикла
   использовать функцию [usleep(3)][5]. Имена путей для записи значений
   сигналов GPIO генерируются с помощью функции [snprintf(3)][6].

[1]: https://www.opennet.ru/man.shtml?topic=open&category=2
[2]: https://www.opennet.ru/man.shtml?topic=read&category=2&russian=0
[3]: https://www.opennet.ru/man.shtml?topic=write&category=2
[4]: https://www.opennet.ru/man.shtml?topic=lseek&category=2&russian=0
[5]: https://www.opennet.ru/man.shtml?topic=usleep&category=3&russian=0
[6]: https://www.opennet.ru/man.shtml?topic=snprintf&category=3&russian=2

## Примеры для базовой задачи

1. Анализ аргументов командной строки.  
   См. Лабораторная работа №2, пример №1.

2. Генерация путевого имени.  
   См. Лабораторная работа №2, пример №2.

3. Открытие файла для получения ассоциированного файлового дескриптора.  
   См. Лабораторная работа №2, пример №4.

4. Чтение содержимого файла с помощью файлового дескриптора.  
   См. Лабораторная работа №2, пример №6.

5. Запись в файл с помощью файлового дескриптора.  
   См. Лабораторная работа №2, пример №8.

6. Установка файлового смещения в `0`.
    ```c
    #include <unistd.h>

    int fd;
    off_t r_offset;

    r_offset = lseek(fd, 0, SEEK_SET);
    if (r_offset == (off_t) -1) {
            /* Handle error here. */
    }
    ```

7. Организация задержки в 100 мс.
    ```c
    #include <unistd.h>

    usleep(100000);
    ```

## Наблюдение результатов

Для наблюдения эффекта выполнения программы необходимо запустить программу и во
время ее выполнения записать в файл */sys/class/gpio/gpio**N**/value* значение
**0** или **1**, где **N** это значение аргумента **IN_GPIO**. В результате
записи **0** желтый светодиод на соответствующем порте загорится, а в
результате записи **1** погаснет. Такое же поведение должно наблюдаться и на
порте который соответствует аргументу **OUT_GPIO**. Запись можно осуществлять с
помощью shell-команды: *echo **X** > /sys/class/gpio/gpio**N**/value*,
где **X** это **0** или **1**, а **N** это значение аргумента **IN_GPIO**.
Например:

```console
$ echo 0 > /sys/class/gpio/gpio472/value
```

# Усложненная задача

Решить базовую задачу с конфигурируемой задержкой воспроизведения. Задержка
воспроизведения задается дополнительным необязательным позиционным аргументом.

## Рекомендации по выполнению усложненной задачи

Задержка воспроизведения реализуется путем использования очереди на основе
массива. Начало очереди - самый старый элемент. Конец очереди - самый новый.
Все элементы очереди являются значениями входного сигнала GPIO. Элемент в самом
начале очереди записывается в выходной сигнал GPIO. После каждой записи в
выходной сигнал GPIO очередь сдвигается по направлению от конца к началу,
вытесняя самый старый элемент очереди. Размер очереди определяет задержку.
