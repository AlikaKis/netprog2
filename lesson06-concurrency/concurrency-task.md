
# Базовая задача

Разработать сервер мультиплексирования текстовых сообщений, принимаемых из
нескольких пакетных UNIX-сокетов. Каждое сообщение содержит одну строку текста.
Мультиплексированный поток сообщений необходимо выводить в стандартный поток
вывода эмулятора терминала.

## Описание базовой задачи

Для решения поставленной задачи предоставляется готовый клиент. Данный клиент
отправляет сообщения через пакетный UNIX-сокет на сервер. В качестве аргументов
клиенту предоставляются желаемый тип используемого сокета и его адрес.
Пример запуска клиента:

```console
$ ./lab_06_client -d -a ADDRESS
```

Опция **-d** для пакетных UNIX-сокетов. Опция **-s** для потоковых UNIX-сокетов.
**ADDRESS** - публичный адрес сервера.

## Алгоритм решения базовой задачи

1. Создать **N** серверных пакетных UNIX-сокетов. Для этого необходимо
   воспользоваться функцией [socket(2)][1].

2. Привязать **N** серверных пакетных UNIX-сокетов к публичным адресам.
   Это можно сделать с помощью функции [bind(2)][2]. Стоит отметить,
   что для  привязки UNIX-сокета к публичному адресу необходимо чтобы файл,
   соответствующий данному адресу, отсутствовал в файловой системе.
   Для удаления файла можно воспользоваться функцией [remove(3)][3].

3. Ожидать готовности чтения для любого из **N** файловых дескрипторов,
   ассоциированных с пакетными UNIX-сокетами. Ожидание выполняется с
   использованием функции [select(2)][4].

4. В случае наличия возможности чтения данных прочитать сообщение из
   UNIX-сокета с помощью функции [recv(2)][5] и отобразить прочитанное
   сообщение в эмуляторе терминала.

5. Вернуться к пункту №3.

[1]: https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=socket&category=2
[2]: https://www.opennet.ru/cgi-bin/opennet/man.cgi?topic=bind&category=2
[3]: https://www.opennet.ru/man.shtml?topic=remove&category=3&russian=0
[4]: https://www.opennet.ru/man.shtml?topic=select&category=2&russian=0
[5]: https://www.opennet.ru/man.shtml?topic=recv&category=2&russian=0
[6]: https://www.opennet.ru/man.shtml?topic=timeradd&category=3&russian=2
[7]: https://www.opennet.ru/man.shtml?topic=gettimeofday&category=2&russian=0

## Примеры для базовой задачи

1. Создание пакетного UNIX-сокета.

    ```c
    #include <sys/socket.h>

    int sfd;

    sfd = socket(AF_UNIX, SOCK_DGRAM, 0);
    if (sfd == -1) {
            /* Handle error here. */
    }
    ```

2. Удаление файла, соответствующего публичному адресу сервера.  
   См. Лабораторная работа №5, пример №1.

3. Привязка UNIX-сокета к публичному адресу.  
   См. Лабораторная работа №5, пример №2.

4. Ожидание готовности чтения для файлового дескриптора `fd`.

    ```c
    #include <sys/select.h>

    fd_set readfds;
    int nfds;
    int fd;
    int ret;

    FD_ZERO(readfds);
    nfds = 0;

    if (fd >= FD_SETSIZE) {
            /* Handle error here. */
    }
    if (fd >= nfds)
            nfds = fd + 1;
    FD_SET(fd, &readfds);

    ret = select(nfds, &readfds, NULL, NULL, NULL);
    if (ret == -1) {
            /* Handle error here. */
    }

    for (fd = 0; fd < nfds; fd++) {
            if (FD_ISSET(fd, &readfds)) {
                    /* FD is ready for read. */
            }
    }

    ```

   Необходимо отметить, что `select` изменяет передаваемые ему наборы
   файловых дескрипторов, в частности `readfds`, поэтому после каждого
   использования `select` необходимо повторно инициализировать `readfds`.

5. Получение сообщения от клиента.  
   См. Лабораторная работа №4, пример №6.

# Усложненная задача

Разработать сервер мультиплексирования текстовых потоков, принимаемых из
нескольких потоковых UNIX-сокетов. Приложение должно читать данные со скоростью
не более 1 символа в секунду для каждого потокового UNIX-сокета.
Мультиплексированный поток символов необходимо выводить в стандартный поток
вывода эмулятора терминала.

## Рекомендации по выполнению усложненной задачи

Для ограничения скорости чтения символов из потокового UNIX-сокета необходимо
прочитать один символ из потокового UNIX-сокета, вывести его в стандартный
поток вывода эмулятора терминала и установить таймер. На время работы таймера
требуется приостановить чтение символов, а после истечения таймера возобновить.
Для организации таймера необходимо задействовать функцию [select(2)][4].
У каждого файлового дескриптора, соответствующего потоковому UNIX-сокету,
должен быть свой, независимый от других, таймер.

## Примеры для усложненной задачи

1. Перевод UNIX-сокета из передающего в слушающий.  
   См. Лабораторная работа №5, пример №1.

2. Прием соединения от клиента.  
   См. Лабораторная работа №5, пример №2.

3. Добавление времени `b` ко времени `a` с сохранением результата в `c`.

    ```c
    #include <sys/time.h>

    struct timeval a;
    struct timeval b;
    struct timeval c;

    a.tv_sec = 1;
    a.tv_usec = 500000;
    b.tv_sec = 2;
    b.tv_usec = 0;

    timeradd(&a, &b, &c);
    ```

4. Вычитание времени `b` из времени `a` с сохранением результата в `c`.

    ```c
    #include <sys/time.h>

    struct timeval a;
    struct timeval b;
    struct timeval c;

    a.tv_sec = 1;
    a.tv_usec = 500000;
    b.tv_sec = 0;
    b.tv_usec = 500000;

    timersub(&a, &b, &c);
    ```

5. Сравнение времени `b` и времени `a`.

    ```c
    #include <sys/time.h>

    struct timeval a;
    struct timeval b;

    a.tv_sec = 1;
    a.tv_usec = 0;
    b.tv_sec = 2;
    b.tv_usec = 0;

    if (timercmp(&a, &b, >=)) {
            /* a >= b */
    } else {
            /* a < b */
    }
    ```

6. Получение текущего времени.

    ```c
    #include <sys/time.h>

    struct timeval current_time_abs;

    gettimeofday(&current_time_abs, NULL);
    ```

# Наблюдение результатов

Для наблюдения работы серверного приложения необходимо запустить три эмулятора
терминала. В первом эмуляторе терминала запустить серверное приложение.
Во втором и третьем - клиентские приложения.

Запуск клиента (пакетный UNIX-сокет):

```console
$ ./lab_06_client -d -a ADDRESS
```

Запуск клиента (потоковый UNIX-сокет):

```console
$ ./lab_05_client -s -a ADDRESS
```

После этого необходимо передать данные в стандартный поток ввода клиентов и
наблюдать результат мультиплексирования на сервере. Стоит отметить, что при
вводе данных через эмулятор терминала, данные в стандартном потоке ввода
клиента появятся только после нажатия клавиши **Enter**.

Пакетные UNIX-сокеты:
В стандартном потоке вывода сервера должны появиться сообщения от всех клиентов.

Потоковые UNIX-сокеты:
В стандартном потоке вывода сервера должны появиться символы от всех клиентов.
При этом символы от одного клиента должны появляться не чаще заданного
интервала времени.
